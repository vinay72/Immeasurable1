{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nfunction t() {\n  var data = _interopRequireWildcard(require(\"@babel/types\"));\n\n  t = function t() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _helperFunctionName() {\n  var data = _interopRequireDefault(require(\"@babel/helper-function-name\"));\n\n  _helperFunctionName = function _helperFunctionName() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction toComputedKey() {\n  var node = this.node;\n  var key;\n\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t().isIdentifier(key)) key = t().stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  var body = this.get(\"body\");\n  var bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  var statements = [];\n  var stringPath = \"body\";\n  var key;\n  var listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t().returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t().expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t().blockStatement(statements);\n  var parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$allowInsertArrow = _ref.allowInsertArrow,\n      allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,\n      _ref$specCompliant = _ref.specCompliant,\n      specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant;\n\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  var thisBinding = hoistFunctionEnvironment(this, specCompliant, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (specCompliant) {\n    var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t().objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t().expressionStatement(t().callExpression(this.hub.addHelper(\"newArrowCheck\"), [t().thisExpression(), checkBinding ? t().identifier(checkBinding.name) : t().identifier(thisBinding)])));\n    this.replaceWith(t().callExpression(t().memberExpression((0, _helperFunctionName().default)(this, true) || this.node, t().identifier(\"bind\")), [checkBinding ? t().identifier(checkBinding.name) : t().thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath) {\n  var specCompliant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var thisEnvFn = fnPath.findParent(function (p) {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  var inConstructor = thisEnvFn && thisEnvFn.node.kind === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  var _getScopeInformation = getScopeInformation(fnPath),\n      thisPaths = _getScopeInformation.thisPaths,\n      argumentsPaths = _getScopeInformation.argumentsPaths,\n      newTargetPaths = _getScopeInformation.newTargetPaths,\n      superProps = _getScopeInformation.superProps,\n      superCalls = _getScopeInformation.superCalls;\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    var allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function: function Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n      ClassProperty: function ClassProperty(child) {\n        child.skip();\n      },\n      CallExpression: function CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n    });\n    var superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(function (superCall) {\n      var callee = t().identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  var thisBinding;\n\n  if (thisPaths.length > 0 || specCompliant) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (!specCompliant || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(function (thisChild) {\n        var thisRef = thisChild.isJSX() ? t().jsxIdentifier(thisBinding) : t().identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (specCompliant) thisBinding = null;\n    }\n  }\n\n  if (argumentsPaths.length > 0) {\n    var argumentsBinding = getBinding(thisEnvFn, \"arguments\", function () {\n      return t().identifier(\"arguments\");\n    });\n    argumentsPaths.forEach(function (argumentsChild) {\n      var argsRef = t().identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    var newTargetBinding = getBinding(thisEnvFn, \"newtarget\", function () {\n      return t().metaProperty(t().identifier(\"new\"), t().identifier(\"target\"));\n    });\n    newTargetPaths.forEach(function (targetChild) {\n      var targetRef = t().identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    var flatSuperProps = superProps.reduce(function (acc, superProp) {\n      return acc.concat(standardizeSuperProperty(superProp));\n    }, []);\n    flatSuperProps.forEach(function (superProp) {\n      var key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n\n      if (superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      })) {\n        var _superBinding = getSuperPropCallBinding(thisEnvFn, key);\n\n        if (superProp.node.computed) {\n          var prop = superProp.get(\"property\").node;\n          superProp.replaceWith(t().identifier(_superBinding));\n          superProp.parentPath.node.arguments.unshift(prop);\n        } else {\n          superProp.replaceWith(t().identifier(_superBinding));\n        }\n      } else {\n        var isAssignment = superProp.parentPath.isAssignmentExpression({\n          left: superProp.node\n        });\n\n        var _superBinding2 = getSuperPropBinding(thisEnvFn, isAssignment, key);\n\n        var args = [];\n\n        if (superProp.node.computed) {\n          args.push(superProp.get(\"property\").node);\n        }\n\n        if (isAssignment) {\n          var value = superProp.parentPath.node.right;\n          args.push(value);\n          superProp.parentPath.replaceWith(t().callExpression(t().identifier(_superBinding2), args));\n        } else {\n          superProp.replaceWith(t().callExpression(t().identifier(_superBinding2), args));\n        }\n      }\n    });\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    var assignmentPath = superProp.parentPath;\n    var op = assignmentPath.node.operator.slice(0, -1);\n    var value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      var tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t().memberExpression(superProp.node.object, t().assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t().binaryExpression(op, t().memberExpression(superProp.node.object, t().identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t().memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t().binaryExpression(op, t().memberExpression(superProp.node.object, t().identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    var updateExpr = superProp.parentPath;\n\n    var _tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n\n    var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    var parts = [t().assignmentExpression(\"=\", _tmp, t().memberExpression(superProp.node.object, computedKey ? t().assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t().assignmentExpression(\"=\", t().memberExpression(superProp.node.object, computedKey ? t().identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t().binaryExpression(\"+\", t().identifier(_tmp.name), t().numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t().identifier(_tmp.name));\n    }\n\n    updateExpr.replaceWith(t().sequenceExpression(parts));\n    var left = updateExpr.get(\"expressions.0.right\");\n    var right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", function (thisBinding) {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t().thisExpression();\n    var supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function: function Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n      ClassProperty: function ClassProperty(child) {\n        child.skip();\n      },\n      CallExpression: function CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t().assignmentExpression(\"=\", t().identifier(thisBinding), t().identifier(\"this\"))]);\n      }\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", function () {\n    var argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t().arrowFunctionExpression([t().restElement(argsBinding)], t().callExpression(t().super(), [t().spreadElement(t().identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropCallBinding(thisEnvFn, propName) {\n  return getBinding(thisEnvFn, \"superprop_call:\".concat(propName || \"\"), function () {\n    var argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    var argsList = [t().restElement(argsBinding)];\n    var fnBody;\n\n    if (propName) {\n      fnBody = t().callExpression(t().memberExpression(t().super(), t().identifier(propName)), [t().spreadElement(t().identifier(argsBinding.name))]);\n    } else {\n      var method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t().callExpression(t().memberExpression(t().super(), t().identifier(method.name), true), [t().spreadElement(t().identifier(argsBinding.name))]);\n    }\n\n    return t().arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  var op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, \"superprop_\".concat(op, \":\").concat(propName || \"\"), function () {\n    var argsList = [];\n    var fnBody;\n\n    if (propName) {\n      fnBody = t().memberExpression(t().super(), t().identifier(propName));\n    } else {\n      var method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t().memberExpression(t().super(), t().identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      var valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t().assignmentExpression(\"=\", fnBody, t().identifier(valueIdent.name));\n    }\n\n    return t().arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  var cacheKey = \"binding:\" + key;\n  var data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    var id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  var thisPaths = [];\n  var argumentsPaths = [];\n  var newTargetPaths = [];\n  var superProps = [];\n  var superCalls = [];\n  fnPath.traverse({\n    ClassProperty: function ClassProperty(child) {\n      child.skip();\n    },\n    Function: function Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n    ThisExpression: function ThisExpression(child) {\n      thisPaths.push(child);\n    },\n    JSXIdentifier: function JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n    CallExpression: function CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n    MemberExpression: function MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n    ReferencedIdentifier: function ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      argumentsPaths.push(child);\n    },\n    MetaProperty: function MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n  });\n  return {\n    thisPaths: thisPaths,\n    argumentsPaths: argumentsPaths,\n    newTargetPaths: newTargetPaths,\n    superProps: superProps,\n    superCalls: superCalls\n  };\n}","map":null,"metadata":{},"sourceType":"script"}